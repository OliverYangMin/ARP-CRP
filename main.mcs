require '02Module.functions'
require '01Class.Flight'
require '01Class.Craft'
require '01Class.Port'
require '01Class.Master'
require '01Class.Label'
require '01Class.Column'
require '01Class.Evaluator'
minpq = require '03Algorithms.data.minpq'
--require 'mobdebug'.off()


function Craft:createGraph()
    self.nodes = {[0] = {fid = 0, labels = {Label:new(self.id, 0)}, adj = {}}}
    for f,flight in ipairs(flights) do
        if flight:isOperable(self) then
            self.nodes[#self.nodes + 1] = {fid = f, labels = {}, adj = {}, indegree = 0}
            if flight.port1 == self.start then
                table.insert(self.nodes[0].adj, #self.nodes)
            end 
        end 
    end
    self:topoSort(self:addEdgesAdjIndegree())
end 
init()


function Craft:labelSetting()
    for i=0,#self.order do
        local node = self.nodes[self.order[i]]
        for _,label in ipairs(node.labels) do
            for _,node_id in ipairs(node.adj) do 
              
                label:extendNode(node, self.nodes[node_id])  
            end 
        end
    end 
end 
function Label:extendNode(node1, node2)
    local flight1 = node1.fid == 0 and {port2 = crafts[self.cid].start, time2 = crafts[self.cid].stime} or flights[node1.fid]
    local flight2 = flights[node2.fid]
    if not flight2 then
        print(self.cid, ' ', node2.fid)
    end 
    local tag, turnaround_time = Label:new(self.cid, node2.fid), ports[flight1.port2][crafts[self.cid].tp]
    tag.delay = math.max(0, flight1.time2 + self.delay + turnaround_time - flight2.time1)            
    if not flight2:isDelayFeasible(tag.delay) then return end 
    
    tag.cost = self.cost + evaluator:getDelayCost(flight2, tag.delay, crafts[self.cid]) + evaluator:getCraftSwapCost(flight2, crafts[self.cid]) - flight2.dual     
    
    for _,label in ipairs(node2.labels) do
        if label:isDominate(tag) then 
            return 
        end 
    end 
    self:dominateLabelSet(node2.labels)
    tag.pre = self
    table.insert(node2.labels, tag)
end 
repeat 
    local master = Master:new()
    master:WriteLP()
    master:lpSolve()
    master:updateSolution()
    master:setDuals()
     
    local not_opt = master:solveSubproblem()
    clearLabels()
    
    print(master.objective)
    print(#columns)
until not not_opt

local master = Master:new()
master:WriteLP()
master:integerSolve()
master:updateSolution()
print(master.objective)




