require '02Module.functions'
require '01Class.Flight'
require '01Class.Craft'
require '01Class.Port'
require '01Class.Master'
require '01Class.Label'
require '01Class.Column'
require '01Class.Evaluator'
minpq = require '03Algorithms.data.minpq'
--require 'mobdebug'.off()
function Evaluator:getCost(column)
    local cost, time = 0, 0
    local craft = crafts[column.cid]
    for i=#column-1,1,-1 do
        local flight = flights[column[i]]
        local delay = math.max(0, time - flight.time1)
        
        ---航班延误：延误班次=2，延误时间=5，乘客延误时间=7 ---换机:机型更换=4, 乘客减少=6 驻地=3
        cost = cost + self:getDelayCost(flight, delay, craft) + self:getCraftSwapCost(flight, craft)
        if i < #column - 1 then cost = cost + self:getBaseChangeCost(flights[column[i+1]], flight, crafts[column.cid].base) end  
        --- 联程=10
--        if flight.double then
--            if i == #column or column[i+1] ~= flight.double then
--                cost = cost + PENALTY[10]
--            end 
--        end 
        time = flight.time2 + delay + ports[flight.port2][craft.tp]
    end
    
    if flights[column[1]].port2 ~= craft.base[#craft.base] then
        return cost + PENALTY[3]
    end 
    return cost 
end 
init()

function Master:SetObjFunction()
    for f,flight in pairs(flights) do -- no double flight cancel: both cancel or single cancel
        if flight.impacted then 
            self.obj[#self.obj+1] = PENALTY[1] - PENALTY[2] - 120 * 25 + (PENALTY[6] - 1.5) * flight.pass
        else
            self.obj[#self.obj+1] = PENALTY[1] + PENALTY[6] * flight.pass
        end 
    end 
    ---the cost for every route has been found
    for i=1,#columns do
        self.obj[#self.obj+1] = columns[i]:getCost()
    end 
    local a = 0
    for c,craft in pairs(crafts) do
        self.obj[#self.obj+1] = craft.start == craft.base[#craft.base] and 0 or PENALTY[3]
        a = a + 1
    end 
    SetObjFunction(self.lp, self.obj, 'min')
end 

function Master:AddConstraint()
    local coeff, changed = {}, {}
    for j=1,#self.obj do coeff[j] = 0 end 
    local function resetCoeff()
        for i=1,#changed do
            coeff[changed[i]] = 0
        end 
        changed = {}
    end  
    ---constraint 1 every flight been execute by only one route or be canceled
    for i=1,#flights do
        coeff[i] = 1
        changed[#changed+1] = i
        for j=1,#columns do
            if columns[j]:isInclude(i) then 
                coeff[#flights+j] = 1
                changed[#changed+1] = #flights + j
            end 
        end 
        AddConstraint(self.lp, coeff, '=', 1)
        resetCoeff()
    end
    ---constraint 2 every flight been execute by only one route or be canceled
    local c = 1
    for cid,craft in pairs(crafts) do
        for j=1,#columns do 
            if columns[j].craft == cid then 
                coeff[#flights+j] = 1
                changed[#changed+1] = #flights + j
            end 
        end 
        --coeff[#flights+#columns+c] = 1 
        AddConstraint(self.lp, coeff, '<=', 1)
        resetCoeff()
        c = c + 1
    end 
end 


function Label:extendNode(node1, node2)
    local flight1 = node1.fid == 0 and {port2 = crafts[self.cid].start, time2 = crafts[self.cid].stime, date = 1} or flights[node1.fid]
    local flight2 = flights[node2.fid]
    local tag, turnaround_time = Label:new(self.cid, node2.fid), ports[flight1.port2][crafts[self.cid].tp]
    tag.delay = math.max(0, flight1.time2 + self.delay + turnaround_time - flight2.time1)            
    if not flight2:isDelayFeasible(tag.delay) then return end 
    tag.cost = self.cost + evaluator:getDelayCost(flight2, tag.delay, crafts[self.cid]) + evaluator:getCraftSwapCost(flight2, crafts[self.cid]) + evaluator:getBaseChangeCost(flight1, flight2, crafts[self.cid].base) - flight2.dual     
   
    for _,label in ipairs(node2.labels) do
        if label:isDominate(tag) then 
            return 
        end 
    end 
    
    self:dominateLabelSet(node2.labels)
    
    tag.pre = self
    
    table.insert(node2.labels, tag)
end 

function Craft:convertLabel2Column()
    local pqueue = minpq.create(function(a, b) return a.cost - b.cost end)
    for _,node in ipairs(self.nodes) do
        for _,label in ipairs(node.labels) do
            label.cost = label.cost - self.dual
            if flights[label.fid].port2 ~= self.base[#self.base] then
                label.cost =  label.cost + PENALTY[3]
            end 
            if label.cost < -0.000001 then
                pqueue:enqueue(label)
            end 
        end 
    end 
    return pqueue
end 
--DEBUG = 13
repeat 
    
    local master = Master:new()
    --require 'mobdebug'.on()
    master:WriteLP()
    if #columns > 10000 then
        master:cplexSolve()
    else
        master:lpSolve()
    end 
    master:updateSolution()
    master:setDuals()
--    if #columns >= 4298 then
--        
--        a = 1
--    end
    local not_opt = master:solveSubproblem()
    clearLabels()
 
    print(master.objective)
    print(#columns)
until not not_opt

--local master = Master:new()
--master:WriteLP()
--master:integerSolve()
--master:updateSolution()
--print(master.objective)




